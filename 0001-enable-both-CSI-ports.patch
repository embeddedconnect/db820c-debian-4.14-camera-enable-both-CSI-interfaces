From 2021ce1b43abc912e3cabd0c45377df7ede3b0cb Mon Sep 17 00:00:00 2001
From: laxman <laxman@inforcecomputing.com>
Date: Wed, 18 Jul 2018 10:00:17 +0530
Subject: [PATCH] enable both CSI ports

---
 arch/arm64/boot/dts/qcom/apq8096-db820c.dtsi | 18 ++++++++-------
 arch/arm64/boot/dts/qcom/msm8996-pins.dtsi   | 16 ++++++-------
 arch/arm64/configs/defconfig                 |  1 +
 drivers/i2c/busses/i2c-qcom-cci.c            | 34 ++++++++++++++++------------
 drivers/media/i2c/Kconfig                    | 24 ++++++++++----------
 drivers/media/i2c/Makefile                   |  2 +-
 drivers/media/i2c/ov5640.c                   | 10 ++++++++
 drivers/media/i2c/ov5645.c                   | 10 ++++++++
 include/linux/i2c.h                          |  2 +-
 9 files changed, 72 insertions(+), 45 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/apq8096-db820c.dtsi b/arch/arm64/boot/dts/qcom/apq8096-db820c.dtsi
index f49ef69..6d96858 100644
--- a/arch/arm64/boot/dts/qcom/apq8096-db820c.dtsi
+++ b/arch/arm64/boot/dts/qcom/apq8096-db820c.dtsi
@@ -273,10 +273,11 @@
 				compatible = "ovti,ov5640";
 				reg = <0x3b>;
 
-				enable-gpios = <&msmgpio 26 GPIO_ACTIVE_HIGH>;
-				reset-gpios = <&msmgpio 25 GPIO_ACTIVE_LOW>;
+				enable-gpios = <&msmgpio 29 GPIO_ACTIVE_HIGH>;
+				reset-gpios =  <&msmgpio 30 GPIO_ACTIVE_LOW>;
 				pinctrl-names = "default";
 				pinctrl-0 = <&camera_rear_default>;
+                cci-master = <0>;
 
 				clocks = <&mmcc CAMSS_MCLK0_CLK>;
 				clock-names = "xclk";
@@ -286,7 +287,7 @@
 				vdda-supply = <&camera_vdda_2v8>;
 				vddd-supply = <&camera_vddd_1v5>;
 
-				//status = "disabled";
+				status = "ok";
 
 				port {
 					ov5640_ep: endpoint {
@@ -329,20 +330,21 @@
 				compatible = "ovti,ov5645";
 				reg = <0x3a>;
 
-				enable-gpios = <&msmgpio 133 GPIO_ACTIVE_HIGH>;
+				enable-gpios = <&msmgpio 26 GPIO_ACTIVE_HIGH>;
 				reset-gpios = <&msmgpio 23 GPIO_ACTIVE_LOW>;
 				pinctrl-names = "default";
 				pinctrl-0 = <&camera_front_default>;
+                cci-master = <1>;
 
 				clocks = <&mmcc CAMSS_MCLK2_CLK>;
 				clock-names = "xclk";
-				clock-frequency = <24000000>;
+				clock-frequency = <23880000>;
 
 				vdddo-supply = <&camera_vdddo_1v8>;
 				vdda-supply = <&camera_vdda_2v8>;
 				vddd-supply = <&camera_vddd_1v5>;
 
-				status = "disabled";
+				status = "ok";
 
 				port {
 					ov5645_3_ep: endpoint {
@@ -366,7 +368,7 @@
 						clock-lanes = <7>;
 						data-lanes = <0 1>;
 						remote-endpoint = <&ov5640_ep>;
-						//status = "disabled";
+						status = "ok";
 					};
 				};
 				port@1 {
@@ -384,7 +386,7 @@
 						clock-lanes = <7>;
 						data-lanes = <0 1>;
 						remote-endpoint = <&ov5645_3_ep>;
-						status = "disabled";
+						status = "ok";
 					};
 				};
 			};
diff --git a/arch/arm64/boot/dts/qcom/msm8996-pins.dtsi b/arch/arm64/boot/dts/qcom/msm8996-pins.dtsi
index ddbec6e..d34b217 100644
--- a/arch/arm64/boot/dts/qcom/msm8996-pins.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8996-pins.dtsi
@@ -304,10 +304,10 @@
         cci0_default: cci0_default {
                 mux {
                         function = "cci_i2c";
-                        pins = "gpio17", "gpio18";
+                        pins = "gpio17", "gpio18", "gpio19", "gpio20";
                 };
                 config {
-                        pins = "gpio17", "gpio18";
+                        pins = "gpio17", "gpio18", "gpio19", "gpio20";
                         drive-strength = <16>;
                         bias-disable;
                 };
@@ -543,10 +543,10 @@
 	camera_front_default: camera_front_default {
 		mux_pwdn {
 			function = "gpio";
-			pins = "gpio133";
+			pins = "gpio26";
 		};
 		config_pwdn {
-			pins = "gpio133";
+			pins = "gpio26";
 			drive-strength = <16>;
 			bias-disable;
 		};
@@ -575,20 +575,20 @@
 	camera_rear_default: camera_rear_default {
 		mux_pwdn {
 			function = "gpio";
-			pins = "gpio26";
+			pins = "gpio29";
 		};
 		config_pwdn {
-			pins = "gpio26";
+			pins = "gpio29";
 			drive-strength = <16>;
 			bias-disable;
 		};
 
 		mux_rst {
 			function = "gpio";
-			pins = "gpio25";
+			pins = "gpio30";
 		};
 		config_rst {
-			pins = "gpio25";
+			pins = "gpio30";
 			drive-strength = <16>;
 			bias-disable;
 		};
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 263aa4f..ca8e35a 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -382,6 +382,7 @@ CONFIG_VIDEO_RENESAS_VSP1=m
 CONFIG_VIDEO_QCOM_VENUS=m
 # CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
 CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_OV5645=m
 CONFIG_VIDEO_OV7251=m
 CONFIG_DRM=m
 CONFIG_DRM_NOUVEAU=m
diff --git a/drivers/i2c/busses/i2c-qcom-cci.c b/drivers/i2c/busses/i2c-qcom-cci.c
index 143e44d..93e8a0f 100644
--- a/drivers/i2c/busses/i2c-qcom-cci.c
+++ b/drivers/i2c/busses/i2c-qcom-cci.c
@@ -72,7 +72,7 @@
 #define CCI_IRQ_STATUS_0_I2C_M1_ERROR		0x60ee6000
 
 #define CCI_TIMEOUT_MS 100
-#define NUM_MASTERS 1
+#define NUM_MASTERS 2
 #define NUM_QUEUES 2
 
 /* Max number of resources + 1 for a NULL terminator */
@@ -340,15 +340,15 @@ static irqreturn_t cci_isr(int irq, void *dev)
 	return IRQ_HANDLED;
 }
 
-static void cci_halt(struct cci *cci)
+static void cci_halt(struct cci *cci, u8 master)
 {
 	unsigned long time;
 	u32 val = CCI_HALT_REQ_I2C_M0_Q0Q1 | CCI_HALT_REQ_I2C_M1_Q0Q1;
 
-	cci->master[0].complete_pending = true;
+	cci->master[master].complete_pending = true;
 	writel(val, cci->base + CCI_HALT_REQ);
 	time = wait_for_completion_timeout(
-				&cci->master[0].irq_complete,
+				&cci->master[master].irq_complete,
 				msecs_to_jiffies(CCI_TIMEOUT_MS));
 	if (!time)
 		dev_err(cci->dev, "CCI halt timeout\n");
@@ -357,16 +357,20 @@ static void cci_halt(struct cci *cci)
 static int cci_reset(struct cci *cci)
 {
 	unsigned long time;
+    int master;
 
-	cci->master[0].complete_pending = true;
+    for(master = 0; master < NUM_MASTERS; master++)
+    {
+	cci->master[master].complete_pending = true;
 	writel(CCI_RESET_CMD_MASK, cci->base + CCI_RESET_CMD);
 	time = wait_for_completion_timeout(
-				&cci->master[0].irq_complete,
+				&cci->master[master].irq_complete,
 				msecs_to_jiffies(CCI_TIMEOUT_MS));
 	if (!time) {
 		dev_err(cci->dev, "CCI reset timeout\n");
 		return -ETIMEDOUT;
-	}
+	    }
+    }
 
 	return 0;
 }
@@ -426,7 +430,7 @@ static int cci_run_queue(struct cci *cci, u8 master, u8 queue)
 		dev_err(cci->dev, "master %d queue %d timeout\n",
 			master, queue);
 
-		cci_halt(cci);
+		cci_halt(cci, master);
 
 		return -ETIMEDOUT;
 	}
@@ -459,9 +463,8 @@ static int cci_validate_queue(struct cci *cci, u8 master, u8 queue)
 	return ret;
 }
 
-static int cci_i2c_read(struct cci *cci, u16 addr, u8 *buf, u16 len)
+static int cci_i2c_read(struct cci *cci, u16 addr, u8 *buf, u16 len, u8 master)
 {
-	u8 master = 0;
 	u8 queue = QUEUE_1;
 	u32 val;
 	u32 words_read, words_exp;
@@ -512,9 +515,8 @@ static int cci_i2c_read(struct cci *cci, u16 addr, u8 *buf, u16 len)
 	return 0;
 }
 
-static int cci_i2c_write(struct cci *cci, u16 addr, u8 *buf, u16 len)
+static int cci_i2c_write(struct cci *cci, u16 addr, u8 *buf, u16 len, u8 master)
 {
-	u8 master = 0;
 	u8 queue = QUEUE_0;
 	u8 load[12] = { 0 };
 	int i, j;
@@ -555,16 +557,18 @@ static int cci_i2c_write(struct cci *cci, u16 addr, u8 *buf, u16 len)
 static int cci_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 {
 	struct cci *cci = i2c_get_adapdata(adap);
-	int i;
+	int i, master;
 	int ret = 0;
 
+    master = adap->index;
+
 	for (i = 0; i < num; i++) {
 		if (msgs[i].flags & I2C_M_RD)
 			ret = cci_i2c_read(cci, msgs[i].addr, msgs[i].buf,
-					   msgs[i].len);
+					   msgs[i].len, master);
 		else
 			ret = cci_i2c_write(cci, msgs[i].addr, msgs[i].buf,
-					    msgs[i].len);
+					    msgs[i].len, master);
 
 		if (ret < 0) {
 			dev_err(cci->dev, "cci i2c xfer error %d", ret);
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 6e561ff..75bec61 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -583,18 +583,18 @@ config VIDEO_OV5640
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov5640.
 
-#config VIDEO_OV5645
-#	tristate "OmniVision OV5645 sensor support"
-#	depends on OF
-#	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-#	depends on MEDIA_CAMERA_SUPPORT
-#	select V4L2_FWNODE
-#	---help---
-#	  This is a Video4Linux2 sensor-level driver for the OmniVision
-#	  OV5645 camera.
-#
-#	  To compile this driver as a module, choose M here: the
-#	  module will be called ov5645.
+config VIDEO_OV5645
+	tristate "OmniVision OV5645 sensor support"
+	depends on OF
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5645 camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov5645.
 
 config VIDEO_OV5647
 	tristate "OmniVision OV5647 sensor support"
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 0663488..02fa38f 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -62,7 +62,7 @@ obj-$(CONFIG_VIDEO_UPD64031A) += upd64031a.o
 obj-$(CONFIG_VIDEO_UPD64083) += upd64083.o
 obj-$(CONFIG_VIDEO_OV2640) += ov2640.o
 obj-$(CONFIG_VIDEO_OV5640) += ov5640.o
-#obj-$(CONFIG_VIDEO_OV5645) += ov5645.o
+obj-$(CONFIG_VIDEO_OV5645) += ov5645.o
 obj-$(CONFIG_VIDEO_OV5647) += ov5647.o
 obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
 obj-$(CONFIG_VIDEO_OV6650) += ov6650.o
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 24b5fe8..9810200 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -165,6 +165,8 @@ struct ov5640 {
 
 	struct gpio_desc *enable_gpio;
 	struct gpio_desc *rst_gpio;
+
+    u32 master;
 };
 
 static inline struct ov5640 *to_ov5640(struct v4l2_subdev *sd)
@@ -1490,6 +1492,8 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 	struct ov5640 *ov5640 = to_ov5640(sd);
 	int ret = 0;
 
+    ov5640->i2c_client->adapter->index = ov5640->master;
+
 	mutex_lock(&ov5640->power_lock);
 
 	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
@@ -2162,6 +2166,12 @@ static int ov5640_probe(struct i2c_client *client,
 		return ret;
 	}
 
+    ret = of_property_read_u32(dev->of_node, "cci-master", &ov5640->master);
+	if (ret) {
+		dev_err(dev, "could not set cci master index\n");
+		return ret;
+	}
+
 	ov5640->io_regulator = devm_regulator_get(dev, "vdddo");
 	if (IS_ERR(ov5640->io_regulator)) {
 		dev_err(dev, "cannot get io regulator\n");
diff --git a/drivers/media/i2c/ov5645.c b/drivers/media/i2c/ov5645.c
index e5638d0..637fde0 100644
--- a/drivers/media/i2c/ov5645.c
+++ b/drivers/media/i2c/ov5645.c
@@ -117,6 +117,8 @@ struct ov5645 {
 
 	struct gpio_desc *enable_gpio;
 	struct gpio_desc *rst_gpio;
+
+    u32 master;
 };
 
 static inline struct ov5645 *to_ov5645(struct v4l2_subdev *sd)
@@ -754,6 +756,8 @@ static int ov5645_s_power(struct v4l2_subdev *sd, int on)
 	struct ov5645 *ov5645 = to_ov5645(sd);
 	int ret = 0;
 
+    ov5645->i2c_client->adapter->index = ov5645->master;
+
 	mutex_lock(&ov5645->power_lock);
 
 	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
@@ -1224,6 +1228,12 @@ static int ov5645_probe(struct i2c_client *client,
 		return ret;
 	}
 
+    ret = of_property_read_u32(dev->of_node, "cci-master", &ov5645->master);
+	if (ret) {
+		dev_err(dev, "could not set cci master index\n");
+		return ret;
+	}
+
 	ov5645->io_regulator = devm_regulator_get(dev, "vdddo");
 	if (IS_ERR(ov5645->io_regulator)) {
 		dev_err(dev, "cannot get io regulator\n");
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index d501d39..d9e2cf1 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -582,7 +582,7 @@ struct i2c_adapter {
 	int retries;
 	struct device dev;		/* the adapter device */
 
-	int nr;
+	int nr, index;
 	char name[48];
 	struct completion dev_released;
 
-- 
2.7.4

